package dk.trustworks.userservice.repositories;

import dk.trustworks.userservice.model.*;
import dk.trustworks.userservice.network.queries.model.JoinedUser;
import io.reactivex.Completable;
import io.reactivex.Single;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.sql.ResultSet;
import io.vertx.ext.sql.SQLOptions;
import io.vertx.reactivex.ext.jdbc.JDBCClient;
import io.vertx.reactivex.ext.sql.SQLConnection;

import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class UserRepository {

    private JDBCClient jdbc;

    public UserRepository(JDBCClient jdbc) {
        this.jdbc = jdbc;
    }

    private Single<SQLConnection> connect() {
        return jdbc.rxGetConnection()
                .map(c -> c.setOptions(new SQLOptions().setAutoGeneratedKeys(true)));
    }

    public Single<List<User>> getAllUsers() {

        String sql = "SELECT " +
                "u.active, " +
                "u.birthday, " +
                "u.created, " +
                "u.email, " +
                "u.firstname, " +
                "u.lastname, " +
                "u.password, " +
                "u.slackusername, " +
                "u.username, " +
                "u.uuid, " +
                "roles.uuid as roleuuid, " +
                "roles.role, " +
                "salary.uuid as salaryuuid, " +
                "salary.useruuid as useruuid, " +
                "salary.salary, " +
                "salary.activefrom, " +
                "user_contactinfo.id as contactid, " +
                "user_contactinfo.street, " +
                "user_contactinfo.postalcode, " +
                "user_contactinfo.city, " +
                "user_contactinfo.phone, " +
                "userstatus.uuid as statusuuid, " +
                "userstatus.status, " +
                "userstatus.statusdate, " +
                "userstatus.allocation, " +
                "userstatus.type " +
                "FROM " +
                "usermanager.user u " +
                "LEFT OUTER JOIN usermanager.userstatus userstatus ON u.uuid = userstatus.useruuid " +
                "LEFT OUTER JOIN usermanager.salary salary ON u.uuid = salary.useruuid " +
                "LEFT OUTER JOIN usermanager.roles roles ON u.uuid = roles.useruuid " +
                "LEFT OUTER JOIN usermanager.user_contactinfo user_contactinfo ON u.uuid = user_contactinfo.useruuid " +
                "ORDER BY " +
                "u.username;";

        return getListSingle(sql);
    }

    public Single<User> getOne(String uuid) {
        String sql = "SELECT " +
                "u.active, " +
                "u.birthday, " +
                "u.created, " +
                "u.email, " +
                "u.firstname, " +
                "u.lastname, " +
                "u.password, " +
                "u.slackusername, " +
                "u.username, " +
                "u.uuid, " +
                "roles.uuid as roleuuid, " +
                "roles.role, " +
                "salary.uuid as salaryuuid, " +
                "salary.useruuid as useruuid, " +
                "salary.salary, " +
                "salary.activefrom, " +
                "user_contactinfo.id as contactid, " +
                "user_contactinfo.street, " +
                "user_contactinfo.postalcode, " +
                "user_contactinfo.city, " +
                "user_contactinfo.phone, " +
                "userstatus.uuid as statusuuid, " +
                "userstatus.status, " +
                "userstatus.statusdate, " +
                "userstatus.allocation, " +
                "userstatus.type " +
                "FROM " +
                "usermanager.user u " +
                "LEFT OUTER JOIN usermanager.userstatus userstatus ON u.uuid = userstatus.useruuid " +
                "LEFT OUTER JOIN usermanager.salary salary ON u.uuid = salary.useruuid " +
                "LEFT OUTER JOIN usermanager.roles roles ON u.uuid = roles.useruuid " +
                "LEFT OUTER JOIN usermanager.user_contactinfo user_contactinfo ON u.uuid = user_contactinfo.useruuid " +
                "WHERE u.uuid LIKE ? " +
                "ORDER BY u.username;";

        return getUserSingle(uuid, sql);
    }

    public Single<User> findByUsername(String username) {
        String sql = "SELECT " +
                "u.active, " +
                "u.birthday, " +
                "u.created, " +
                "u.email, " +
                "u.firstname, " +
                "u.lastname, " +
                "u.password, " +
                "u.slackusername, " +
                "u.username, " +
                "u.uuid, " +
                "roles.uuid as roleuuid, " +
                "roles.role, " +
                "salary.uuid as salaryuuid, " +
                "salary.useruuid as useruuid, " +
                "salary.salary, " +
                "salary.activefrom, " +
                "user_contactinfo.id as contactid, " +
                "user_contactinfo.street, " +
                "user_contactinfo.postalcode, " +
                "user_contactinfo.city, " +
                "user_contactinfo.phone, " +
                "userstatus.uuid as statusuuid, " +
                "userstatus.status, " +
                "userstatus.statusdate, " +
                "userstatus.allocation, " +
                "userstatus.type " +
                "FROM " +
                "usermanager.user u " +
                "LEFT OUTER JOIN usermanager.userstatus userstatus ON u.uuid = userstatus.useruuid " +
                "LEFT OUTER JOIN usermanager.salary salary ON u.uuid = salary.useruuid " +
                "LEFT OUTER JOIN usermanager.roles roles ON u.uuid = roles.useruuid " +
                "LEFT OUTER JOIN usermanager.user_contactinfo user_contactinfo ON u.uuid = user_contactinfo.useruuid " +
                "WHERE u.username LIKE ? " +
                "ORDER BY u.username;";

        return getUserSingle(username, sql);
    }

    public Single<List<User>> findUsersByDateAndStatusListAndTypes(String date, String[] consultantStatusList, String... consultantTypes) {
        String sql = "SELECT kk.statusdate, u.active, u.birthday, u.created, u.email, u.firstname, u.lastname, u.password, " +
                "u.slackusername, u.username, u.uuid, roles.uuid as roleuuid, roles.role, salary.uuid as salaryuuid, " +
                "salary.useruuid as useruuid, salary.salary, salary.activefrom, user_contactinfo.id as contactid, " +
                "user_contactinfo.street, user_contactinfo.postalcode, user_contactinfo.city, user_contactinfo.phone, " +
                "kk.uuid as statusuuid, kk.status, kk.allocation, kk.type " +
                "FROM usermanager.user u " +
                "LEFT OUTER JOIN usermanager.salary salary ON u.uuid = salary.useruuid " +
                "LEFT OUTER JOIN usermanager.roles roles ON u.uuid = roles.useruuid " +
                "LEFT OUTER JOIN usermanager.user_contactinfo user_contactinfo ON u.uuid = user_contactinfo.useruuid " +
                "LEFT JOIN ( " +
                "SELECT yt.uuid, yt.useruuid, yt.status, yt.statusdate, yt.allocation, yt.type " +
                "FROM userstatus yt " +
                "INNER JOIN ( " +
                "SELECT uuid, useruuid, max(statusdate) created " +
                "FROM userstatus " +
                "WHERE statusdate <= '"+date+"' " +
                "GROUP BY useruuid " +
                ") ss " +
                "ON yt.statusdate = ss.created AND yt.useruuid = ss.useruuid " +
                "WHERE yt.status IN ('"+String.join("','", consultantStatusList)+"') AND yt.type IN ('"+String.join("','", consultantTypes)+"') " +
                ") kk " +
                "ON u.uuid = kk.useruuid " +
                "WHERE kk.status IN ('"+String.join("','", consultantStatusList)+"') AND kk.type IN ('"+String.join("','", consultantTypes)+"') " +
                "ORDER BY u.username;";
        return getListSingle(sql);
    }

    public Single<Integer> calculateCapacityByMonthByUser(String useruuid, String statusdate) {
        return connect().flatMap(connection -> {
            String sql = "SELECT COALESCE(sum(allocation), 0) as totalAllocation FROM user u RIGHT JOIN ( " +
                    "select t.useruuid, t.status, t.statusdate, t.allocation " +
                    "from userstatus t " +
                    "inner join ( " +
                    "select useruuid, status, max(statusdate) as MaxDate " +
                    "from userstatus  WHERE statusdate <= ? " +
                    "group by useruuid " +
                    ") " +
                    "tm on t.useruuid = tm.useruuid and t.statusdate = tm.MaxDate " +
                    ") usi ON u.uuid = usi.useruuid WHERE u.uuid LIKE ? ;";
            JsonArray params = new JsonArray()
                    .add(statusdate)
                    .add(useruuid);
            return connection.rxQueryWithParams(sql, params)
                    .doFinally(connection::close)
                    .map(rs -> {
                        List<JsonObject> rows = rs.getRows();
                        if (rows.size() == 0) {
                            throw new NoSuchElementException("No user with params " + params.encodePrettily());
                        } else {
                            JsonObject row = rows.get(0);
                            return row.getInteger("totalAllocation");
                        }
                    });
        });
    }

    public Completable updateOne(String uuid, User user) {
        return connect().flatMapCompletable(connection -> {
            String sql = "UPDATE " +
                    "usermanager.user " +
                    "SET " +
                    "active = ?, " +
                    "email = ?, " +
                    "firstname = ?, " +
                    "lastname = ?, " +
                    "username = ?, " +
                    "slackusername = ?, " +
                    "birthday = ?" +
                    "WHERE uuid like ?;";
            JsonArray params = new JsonArray()
                    .add(user.isActive())
                    .add(user.getEmail())
                    .add(user.getFirstname())
                    .add(user.getLastname())
                    .add(user.getUsername())
                    .add(user.getSlackusername())
                    .add(user.getBirthday().format(DateTimeFormatter.ofPattern("yyyy-MM-dd")))
                    .add(uuid);
            System.out.println("save 2");
            return connection.rxUpdateWithParams(sql, params)
                    .flatMapCompletable(ur ->
                            ur.getUpdated() == 0 ?
                                    Completable
                                            .error(new NoSuchElementException("No user with uuid " + uuid))
                                    : Completable.complete()
                    )
                    .doFinally(connection::close);
        });
    }

    private Stream<User> getUserStream(List<User> users, ResultSet rs) {
        return rs.getRows().stream().map(JoinedUser::new).map(joinedUser -> {
            if (users.stream().noneMatch(user -> user.getUuid().equals(joinedUser.getUuid()))) {
                User user = new User(joinedUser.getUuid(), joinedUser.isActive(), joinedUser.getEmail(), joinedUser.getFirstname(), joinedUser.getLastname(), joinedUser.getPassword(), joinedUser.getUsername(), joinedUser.getSlackusername(), joinedUser.getBirthday());
                users.add(user);
                addSubItems(joinedUser, user);
                return user;
            } else {
                User existingUser = users.stream().filter(user -> user.getUuid().equals(joinedUser.getUuid())).findFirst().get();
                addSubItems(joinedUser, existingUser);
                return existingUser;
            }
        });
    }

    private void addSubItems(JoinedUser joinedUser, User user) {
        if (joinedUser.getRoleuuid() != null && user.getRoleList().stream().noneMatch(role -> role.getUuid().equals(joinedUser.getRoleuuid()))) {
            user.getRoleList().add(new Role(joinedUser.getRoleuuid(), joinedUser.getRole()));
        }
        if (joinedUser.getContactid() != null && user.getUserContactinfo() != null) {
            user.setUserContactinfo(new UserContactinfo(joinedUser.getContactid(), joinedUser.getStreetName(), joinedUser.getPostalCode(), joinedUser.getCity(), joinedUser.getPhone()));
        }
        if (joinedUser.getSalaryuuid() != null && user.getSalaries().stream().noneMatch(salary -> salary.getUuid().equals(joinedUser.getSalaryuuid()))) {
            user.getSalaries().add(new Salary(joinedUser.getSalaryuuid(), joinedUser.getSalary(), joinedUser.getActivefrom(), joinedUser.getUuid()));
        }
        if(joinedUser.getStatusuuid() != null && user.getStatuses().stream().noneMatch(status -> status.getUuid().equals(joinedUser.getStatusuuid()))) {
            user.getStatuses().add(new UserStatus(joinedUser.getStatusuuid(), joinedUser.getType(), joinedUser.getStatus(), joinedUser.getStatusdate(), joinedUser.getAllocation(), joinedUser.getUuid()));
        }
    }

    private Single<List<User>> getListSingle(String sql) {
        JsonArray params = new JsonArray();
        final List<User> users = new ArrayList<>();
        return connect().flatMap(connection -> connection.rxQueryWithParams(sql, params)
                .map(rs -> getUserStream(users, rs).distinct().collect(Collectors.toList()))
                .doFinally(connection::close));
    }

    private Single<User> getUserSingle(String username, String sql) {
        JsonArray params = new JsonArray().add(username);
        final List<User> users = new ArrayList<>();
        return connect().flatMap(connection -> connection.rxQueryWithParams(sql, params)
                .map(rs -> getUserStream(users, rs).distinct().collect(Collectors.toList()).get(0))
                .doFinally(connection::close));
    }
}
